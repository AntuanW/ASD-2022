#todo
def zad1():
    pass


def zad2():
    """
    Algorytm opiera sie na strukturze find-union.
    2 rownowazne litery zostają połaczone, litera wyzej w alfabecie wskazuje na te lepszą.
    """
    pass


def zad3():
    """
    Sposób 1:
    Dijkstra z wierzchołka s, nastepnie porównujemy otrzymane drzewo z otrzymanym (czy odległości są dobre)
    Sposób 2 (szybszy):
    Bierzemy odległości miedzy wierzchołkami podanymi wraz z drzewem. nastepnie dla kazdej krawedzi wykonujemy relaksacje.
    Jezeli w jakimkolwiek punkcie mozna wykonac relakssacje, drzewo nie jest drzewem najkrótszych ścieżek.
    """
    pass


def zad4():
    """
    Wykorzystujemy algorytm kruskala oraz find union. Lączymy 2 maista jezeli oplaca sie zbudowac miedzy nimi droge.
    """
    pass


def zad5():
    """
     Modyfikacja dijkstry: w relaksacji dodatkowe warunki.
    """
    pass


def zad6():
    """
    Puszczamy dijkstre na zmodyfikowanym grafie.
    Kazdy wierzchołek pomnazamy przez wielkosc zbiornika. Wierzcholek np C0 oznacza, ze dotarlismy do wierzcholka C z pustym bakiem.
    Łączymy krawedzie, wagami koszt tankowań.
    """
    pass


def zad7():
    """
    Dijkstra, ale w kolejce umieszczamy wszystkie sklepy od razu z dist na 0.
    """
    pass


if __name__ == "__main__":

    pass
